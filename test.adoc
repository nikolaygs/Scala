= Упражнение 6: Нишки и многонишково програмиране

Да се разработи софтуер за продажба на сноуборд/ски карти в курорт. 

=== Характеристики на системата
 - използва се каса(гише/терминал) на която се продават карти.
 - курортът има максимален капацитет от 1000 сноубордиста, т.е. не могат да бъдат издадени повече от 1000 карти едновременно. Ако се направи опит да се продадат   повече карти да се изведе грешка (IllegalStateException).
 - всяко гише пази данните за всички издадени карти – име на ползвател и дата на издаване.


=== Възможни операции на каса
 - закупуване на карта – цената на картата е 50 лв и 1 лв депозит.
 - връщане на карта – възстановява депозита на притежателят й. 

=== Жизнен цикъл на сноубордист/скиор
Сноубордистите са конкурентни потребители на системата, пазят като състояние име на ползвателя и техният жизнен цикъл е:
 1.	закупуват си карта от касата
 2.	използват я определено време (Thread.sleep())
 3.	връщат я на касата.

== Задача 1
Моделирайте обектите „Каса/Гише“ и „Сноубордист“ със съответното състояние и методи.

== Задача 2
Пуснете N на брой сноубордисти които конкурентно да се опитват да си закупят карти. Оптимизирайте времето за обслужване на потребителите чрез рециклиране на нишките. След приключване на работния ден (жизнения цикъл на всички сноубордисти) изведете броя карти в наличност и баланса на касата.

== Задача 3
Ако на курорта отидат повече сноубордисти от брой карти, т.е. не може всички да ползват пистите едновременно. Подсигурете, че при освобождаване на карта, неуспялите да си закупят карта от първия път ще бъдат автоматично известени.

== Задача 4 (Optional)
С цел избягване на съхранение на много средства в наличност, има наети служители които биват известявани когато в дадена каса има повече от определена сума пари. Когато това се случи те събират парите от касата (оставят малка наличност) и ги събират в обща сметка(трезор).

== Задача 5 (Optional)
Използването само на една каса е крайно неефективно и несъобразено спрямо броя на сноубордистите. Използвайте подходящи синхронизатори и колекции от java.util.concurrent за да изградите възможност няколко потребители(напр 5) да обслужвани конкурентно без да се използва допълнителна синхронизация.